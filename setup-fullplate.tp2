BACKUP ~fullplate/backup~
AUTHOR ~erik, gibberlings3~
MODDER
VERSION ~beta 1~
NO_IF_EVAL_BUG

BEGIN ~Cosmetic: Fix enchantment levels, magical flag, call things by their right names~
COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~
  PATCH_IF (SOURCE_SIZE < 0x72) BEGIN
    PATCH_PRINT "%SOURCE_FILE%: Invalid, below minimum size"
  END ELSE BEGIN
    READ_BYTE  0x18 "flags"

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~BAND04.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~BLEAT01.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~BLEAT02.ITM~) BEGIN
      WRITE_BYTE 0x18 ("%flags%" BAND 0b10111111)
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~BLEAT03.ITM~) BEGIN
      WRITE_BYTE 0x18 ("%flags%" BAND 0b10111111)
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~BRUENPLA.ITM~) BEGIN
      SAY NAME1 ~Field Plate Mail~
      WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2CHAN01.ITM~) BEGIN
      SAY NAME2 ~Incarnadine Elven Chain +5~
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2KELD01.ITM~) BEGIN
      SAY NAME1 ~Firecam Full Plate Mail~
      SAY NAME2 ~Firecam Full Plate Mail +3~
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2LEAT01.ITM~) BEGIN
      SAY NAME2 ~Human Flesh +8~
      WRITE_BYTE 0x60 8
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2PLAT01.ITM~) BEGIN
      SAY NAME1 ~Ankheg Plate Mail~
      SAY NAME2 ~Ankheg Plate Mail +4~
      WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
      WRITE_BYTE 0x60 4
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2ROBE01.ITM~) BEGIN
      WRITE_BYTE 0x60 7
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2ROBE02.ITM~) BEGIN
      WRITE_BYTE 0x60 7
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2ROBE03.ITM~) BEGIN
      WRITE_BYTE 0x60 7
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~C2VALY01.ITM~) BEGIN
      SAY NAME1 ~Corthala Family Armor~
      SAY NAME2 ~Corthala Family Armor +5~
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN02.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN03.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN05.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN06.ITM~) BEGIN
      WRITE_BYTE 0x60 4
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN07.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN08.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN20.ITM~) BEGIN
      WRITE_BYTE 0x60 6
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CHAN21.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CLCK15.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CLCK16.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~CLCK17.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~D0T#GORI.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~D0T#LEAT.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~DLEAT10.ITM~) BEGIN
      WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~FINIROBE.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~FLAT04.ITM~) BEGIN
      SAY NAME2 ~Dwarven Field Plate +1~
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~J#SPLI06.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT02.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT03.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT05.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT06.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT07.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT08.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT09.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT11.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~LEAT15.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~MGILEAT1.ITM~) BEGIN
      SAY NAME1 ~Leather Armor~
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~MGIPLAT1.ITM~) BEGIN
      SAY NAME1 ~Full Plate Mail~
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~NPARM.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~NPCHAN.ITM~) BEGIN
      SAY NAME1 ~Corthala Family Armor~
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~NPPLAT.ITM~) BEGIN
      SAY NAME1 ~Firecam Full Plate Mail~
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT02.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT05.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT06.ITM~) BEGIN
      SAY NAME1 ~Ankheg Plate Mail~
      WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT08.ITM~) BEGIN
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT09.ITM~) BEGIN
      SAY NAME1 ~Field Plate Mail~
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT10.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT11.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT14.ITM~) BEGIN
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~PLAT18.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    /* Looks like a somewhat stripped down, less-protective, plate mail +4 */
    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~R!KITPLT.ITM~) BEGIN
      SAY NAME1 ~Plate Mail~
      SAY NAME2 ~Bringer of Vengeance: Kitanya's Plate Mail +4~
      WRITE_BYTE 0x60 4
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~RR#ABIH.ITM~) BEGIN
      SAY NAME2 ~Abishai Hide +3~
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~RR#CHN01.ITM~) BEGIN
      SAY NAME2 ~Drow Chain Mail +1~
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~SHARARM.ITM~) BEGIN
      WRITE_BYTE 0x60 9
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~TAMCHAIN.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~TG#BSP2.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~TTLEAT.ITM~) BEGIN
      WRITE_BYTE 0x60 2
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~U#CHAN07.ITM~) BEGIN
      SAY NAME1 ~Chain Mail~
      SAY NAME2 ~Elven Chain of the Hand +3~
      WRITE_BYTE 0x60 3
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~U#HFHEAH.ITM~) BEGIN
      SAY NAME2 ~Cornugan Hide Armor +1~
      WRITE_BYTE 0x60 1
    END

    PATCH_IF ("%SOURCE_FILE%" STRING_EQUAL ~WA2ROBE.ITM~) BEGIN
      WRITE_BYTE 0x60 5
    END
  END
  BUT_ONLY_IF_IT_CHANGES


BEGIN ~Full Plate And Packing Steel: Revised Armour~

ACTION_IF NOT FILE_EXISTS ~override/tb#resisttweak.txt~ THEN BEGIN
    PRINT ~tb#resisttweak.txt not found in override - Refinements HLA component is recommended.~
END

COPY_EXISTING - ~fullplate/classification.txt~ ~fullplate~
    COUNT_2DA_ROWS 0 ~entrycount~
    FOR (i=0;i<~%entrycount%~;i=i+1) BEGIN
        READ_2DA_ENTRY ~%i%~ 0 0 ~name~
        READ_2DA_ENTRY ~%i%~ 1 0 ~class~
        TO_LOWER name
        TO_LOWER class
        SPRINT $class(~%name%~) ~%class%~
    END
    BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING - ~fullplate/thebiglist.txt~ ~fullplate~
    COUNT_2DA_ROWS 0 ~entrycount~
    FOR (i=0;i<~%entrycount%~;i=i+1) BEGIN
        READ_2DA_ENTRY ~%i%~ 0 0 ~name~
        READ_2DA_ENTRY ~%i%~ 1 0 ~_weight~
        READ_2DA_ENTRY ~%i%~ 2 0 ~_dexmod~
        READ_2DA_ENTRY ~%i%~ 3 0 ~_movemod~
        READ_2DA_ENTRY ~%i%~ 4 0 ~_wpnspeedmod~
        READ_2DA_ENTRY ~%i%~ 5 0 ~_baseac~
        READ_2DA_ENTRY ~%i%~ 6 0 ~_slashac~
        READ_2DA_ENTRY ~%i%~ 7 0 ~_crushac~
        READ_2DA_ENTRY ~%i%~ 8 0 ~_pierceac~
        READ_2DA_ENTRY ~%i%~ 9 0 ~_missileac~ /* really only here for the missile attractor */
        READ_2DA_ENTRY ~%i%~ 10 0 ~_slashres~
        READ_2DA_ENTRY ~%i%~ 11 0 ~_crushres~
        READ_2DA_ENTRY ~%i%~ 12 0 ~_pierceres~
        READ_2DA_ENTRY ~%i%~ 13 0 ~_missileres~
        READ_2DA_ENTRY ~%i%~ 14 0 ~_fireres~
        READ_2DA_ENTRY ~%i%~ 15 0 ~_coldres~
        READ_2DA_ENTRY ~%i%~ 16 0 ~_hidemod~
        READ_2DA_ENTRY ~%i%~ 17 0 ~_movesilmod~
        READ_2DA_ENTRY ~%i%~ 18 0 ~_openlockmod~
        READ_2DA_ENTRY ~%i%~ 19 0 ~_disarmtrapmod~
        READ_2DA_ENTRY ~%i%~ 20 0 ~_pickpocketmod~
        READ_2DA_ENTRY ~%i%~ 21 0 ~_spellfailmod~

        TO_LOWER name

        SPRINT $weight(~%name%~)        ~%_weight%~
        SPRINT $dexmod(~%name%~)        ~%_dexmod%~
        SPRINT $movemod(~%name%~)       ~%_movemod%~
        SPRINT $wpnspeedmod(~%name%~)   ~%_wpnspeedmod%~
        SPRINT $baseac(~%name%~)        ~%_baseac%~
        SPRINT $slashac(~%name%~)       ~%_slashac%~
        SPRINT $crushac(~%name%~)       ~%_crushac%~
        SPRINT $pierceac(~%name%~)      ~%_pierceac%~
        SPRINT $missileac(~%name%~)     ~%_missileac%~
        SPRINT $slashres(~%name%~)      ~%_slashres%~
        SPRINT $crushres(~%name%~)      ~%_crushres%~
        SPRINT $pierceres(~%name%~)     ~%_pierceres%~
        SPRINT $missileres(~%name%~)    ~%_missileres%~
        SPRINT $fireres(~%name%~)       ~%_fireres%~
        SPRINT $coldres(~%name%~)       ~%_coldres%~
        SPRINT $hidemod(~%name%~)       ~%_hidemod%~
        SPRINT $movesilmod(~%name%~)    ~%_movesilmod%~
        SPRINT $openlockmod(~%name%~)   ~%_openlockmod%~
        SPRINT $disarmtrapmod(~%name%~) ~%_disarmtrapmod%~
        SPRINT $pickpocketmod(~%name%~) ~%_pickpocketmod%~
        SPRINT $spellfailmod(~%name%~)  ~%_spellfailmod%~
    END
    BUT_ONLY_IF_IT_CHANGES

/* COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~ */
COPY_EXISTING ~band04.itm~ ~override~
  PATCH_IF (SOURCE_SIZE < 0x72) BEGIN
    PATCH_PRINT "%SOURCE_FILE%: Invalid, below minimum size"
  END ELSE BEGIN
    READ_LONG 0x60 enchantment

    SPRINT usename ~~

    // armor type defined for the item in classifications.txt?
    //  (we can guess based on animation type, if not)
    SPRINT classdefined $class(~%SOURCE_RES%~)
    PATCH_IF NOT (~%classdefined%~ STRING_CONTAINS_REGEXP ~class~ == 0) BEGIN
        SPRINT tempname ~%classdefined%%enchantment%~

        // stats listed in thebiglist.txt for the generic armor type?
        SPRINT classenchant $weight(~%tempname%~)
        PATCH_IF NOT (~%classenchant%~ STRING_CONTAINS_REGEXP ~weight~ == 0) BEGIN
            SPRINT usename ~%tempname%~
        END
    END
    
    // adjustments listed in thebiglist.txt for the specific armor?
    SPRINT specialcase $weight(~%SOURCE_RES%~)
    PATCH_IF NOT (~%specialcase%~ STRING_CONTAINS_REGEXP ~weight~ == 0) BEGIN
        SET $weight(~%SOURCE_RES%~)         = $weight(~%SOURCE_RES%~) + $weight(~%usename%~)
        SET $dexmod(~%SOURCE_RES%~)         = $dexmod(~%SOURCE_RES%~) + $dexmod(~%usename%~)
        SET $movemod(~%SOURCE_RES%~)        = $movemod(~%SOURCE_RES%~) + $movemod(~%usename%~)
        SET $wpnspeedmod(~%SOURCE_RES%~)    = $wpnspeedmod(~%SOURCE_RES%~) + $wpnspeedmod(~%usename%~)
        SET $baseac(~%SOURCE_RES%~)         = $baseac(~%SOURCE_RES%~) + $baseac(~%usename%~)
        SET $slashac(~%SOURCE_RES%~)        = $slashac(~%SOURCE_RES%~) + $slashac(~%usename%~)
        SET $crushac(~%SOURCE_RES%~)        = $crushac(~%SOURCE_RES%~) + $crushac(~%usename%~)
        SET $pierceac(~%SOURCE_RES%~)       = $pierceac(~%SOURCE_RES%~) + $pierceac(~%usename%~)
        SET $missileac(~%SOURCE_RES%~)      = $missileac(~%SOURCE_RES%~) + $missileac(~%usename%~)
        SET $slashres(~%SOURCE_RES%~)       = $slashres(~%SOURCE_RES%~) + $slashres(~%usename%~)
        SET $crushres(~%SOURCE_RES%~)       = $crushres(~%SOURCE_RES%~) + $crushres(~%usename%~)
        SET $pierceres(~%SOURCE_RES%~)      = $pierceres(~%SOURCE_RES%~) + $pierceres(~%usename%~)
        SET $missileres(~%SOURCE_RES%~)     = $missileres(~%SOURCE_RES%~) + $missileres(~%usename%~)
        SET $fireres(~%SOURCE_RES%~)        = $fireres(~%SOURCE_RES%~) + $fireres(~%usename%~)
        SET $coldres(~%SOURCE_RES%~)        = $coldres(~%SOURCE_RES%~) + $coldres(~%usename%~)
        SET $hidemod(~%SOURCE_RES%~)        = $hidemod(~%SOURCE_RES%~) + $hidemod(~%usename%~)
        SET $movesilmod(~%SOURCE_RES%~)     = $movesilmod(~%SOURCE_RES%~) + $movesilmod(~%usename%~)
        SET $openlockmod(~%SOURCE_RES%~)    = $openlockmod(~%SOURCE_RES%~) + $openlockmod(~%usename%~)
        SET $disarmtrapmod(~%SOURCE_RES%~)  = $disarmtrapmod(~%SOURCE_RES%~) + $disarmtrapmod(~%usename%~)
        SET $pickpocketmod(~%SOURCE_RES%~)  = $pickpocketmod(~%SOURCE_RES%~) + $pickpocketmod(~%usename%~)
        SET $spellfailmod(~%SOURCE_RES%~)   = $spellfailmod(~%SOURCE_RES%~) + $spellfailmod(~%usename%~)
        SPRINT usename ~%SOURCE_RES%~
    END

    WRITE_LONG 0x4c $weight(~%usename%~)

  END
  BUT_ONLY_IF_IT_CHANGES













/*
 * 
 * 
 * 
 * COPY_EXISTING_REGEXP GLOB ~.*\.itm~ ~override~
 * 	// cutoff values
 * 	SPRINT ~fromfiles~ ~___NOT_REALLY_ANYTHING___~
 * 	SPRINT ~file_name~ ~%SOURCE_RES%~
 * 	SET base_ac = 10
 * 	found = 0
 * 	magic_level = 0
 * 	torem = 0
 *     // 	10 = not armour
 *     // 	11 = special armour
 *     // 	9- = normal armour
 * 
 * 	// find out the type of item
 * 	SPRINT armortype ~arghargh~
 * 	SET base_unide = 0
 * 	FOR (i = 0; i < _#_#_#armorlist; i+= 1)
 * 		BEGIN
 * 		READ_2DA_ENTRY_FORMER ~_#_#_#armorlist~ i 0 armortype
 * 		PATCH_IF FILE_CONTAINS_EVALUATED (~armor/list/%armortype%.txt~ ~-- %file_name% --~) THEN
 * 				BEGIN
 * 				SPRINT ~fromfile~ ~%armortype%.txt~
 * 				SPRINT ~base_file~ ~%armortype%.txt~
 * 				SPRINT ~whatis~ ~%armortype%~
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armorlist~ i 1 base_ac
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armorlist~ i 2 base_unide
 * 				END
 * 			END
 * 
 * 	PATCH_IF FILE_CONTAINS_EVALUATED (~armor/special/%file_name%.txt~ ~ ~)   THEN
 * 		BEGIN
 * 		SPRINT ~fromfile~ ~%file_name%.txt~
 * 		END
 * 
 * 	PATCH_IF (base_ac != 10) THEN //if it's an armor
 * 		BEGIN
 * 		READ_LONG 0x64 ext_off
 * 		READ_SHORT 0x68 ext_count
 * 		READ_LONG 0x6a eff_off
 * 		READ_SHORT 0x6e eq_eff_indx
 * 		READ_SHORT 0x70 eq_eff_count
 * 
 * 				READ_LONG 0x60 magic_level
 * 
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 1  dam_slash
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 2  dam_pierc
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 3  dam_blunt
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 4  dam_missi
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 5  dex_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 6  mov_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 7  spe_failu
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 8  pic_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 9  loc_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 10 tra_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 11 sil_penal
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 12 hid_penal
 *                 READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%fromfile%~ magic_level 13 missile_ac
 * 
 * 				READ_2DA_ENTRY_FORMER ~_#_#_#armor_effects_%base_file%~ 0 5  dex_penal_base
 * 				
 * 				done           = 0
 * 				dam_slash_done = 0
 * 				dam_pierc_done = 0
 * 				dam_blunt_done = 0
 * 				dam_missi_done = 0
 * 				dex_penal_done = 0
 * 				mov_penal_done = 0
 * 				spe_failu_done = 0
 * 				pic_penal_done = 0
 * 				loc_penal_done = 0
 * 				tra_penal_done = 0
 * 				sil_penal_done = 0
 * 				hid_penal_done = 0
 *                 base_ac_done   = 0
 *                 missile_ac_done = 0
 * 				torem = 0
 * 
 * 
 * 				READ_BYTE 0x2c min_dex
 * 				PATCH_IF (min_dex < dex_penal_base + 2) THEN
 * 					BEGIN
 * 					WRITE_BYTE 0x2c dex_penal_base + 2
 * 					END
 * 
 * 				// don't add if the modifier is 0
 * 
 * 				PATCH_IF dam_slash = 0 THEN
 * 					BEGIN
 * 					dam_slash_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF dam_pierc = 0 THEN
 * 					BEGIN
 * 					dam_pierc_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF dam_blunt = 0 THEN
 * 					BEGIN
 * 					dam_blunt_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF dam_missi = 0 THEN
 * 					BEGIN
 * 					dam_missi_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF dex_penal = 0 THEN
 * 					BEGIN
 * 					dex_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF mov_penal < 10 THEN // it applies only if your movement penalty is 5% or larger  :(
 * 					BEGIN
 * 					mov_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF spe_failu = 0 THEN
 * 					BEGIN
 * 					spe_failu_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF pic_penal = 0 THEN
 * 					BEGIN
 * 					pic_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF loc_penal = 0 THEN
 * 					BEGIN
 * 					loc_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF tra_penal = 0 THEN
 * 					BEGIN
 * 					tra_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF sil_penal = 0 THEN
 * 					BEGIN
 * 					sil_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF hid_penal = 0 THEN
 * 					BEGIN
 * 					hid_penal_done = 1
 * 					done += 1
 * 					END
 * 
 * 				PATCH_IF missile_ac = 0 THEN
 * 					BEGIN
 * 					missile_ac_done = 1
 * 					done += 1
 * 					END
 * 
 * 		FOR (i = 0; i < eq_eff_count; i += 1)
 * 			BEGIN
 * 			READ_SHORT (eq_eff_indx + i) * 0x30 + eff_off     opcode ELSE 0
 * 			READ_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 ELSE 0
 * 					READ_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 8 par2 ELSE 0
 * 
 * 					    // dexterity
 * 						PATCH_IF ((opcode = 0xf)  && (dex_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - dex_penal
 * 							dex_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// move silently
 * 						PATCH_IF ((opcode = 0x3b) && (sil_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - sil_penal
 * 							sil_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// spell failure
 * 						PATCH_IF ((opcode = 0x3c) && (spe_failu_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 + spe_failu
 * 							spe_failu_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// slashing damage
 * 						PATCH_IF ((opcode = 0x56) && (dam_slash_done = 0) && (par2 = 0)) THEN
 * 						BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 + dam_slash
 * 							dam_slash_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// crushing damage
 * 						PATCH_IF ((opcode = 0x57) && (dam_blunt_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 + dam_blunt
 * 							dam_blunt_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// piercing damage
 * 						PATCH_IF ((opcode = 0x58) && (dam_pierc_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 + dam_pierc
 * 							dam_pierc_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// missile damage
 * 						PATCH_IF ((opcode = 0x59) && (dam_missi_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 + dam_missi
 * 							dam_missi_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// open locks
 * 						PATCH_IF ((opcode = 0x5a) && (loc_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - loc_penal
 * 							loc_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// find traps
 * 						PATCH_IF ((opcode = 0x5b) && (tra_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - tra_penal
 * 							tra_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// pick pockets
 * 						PATCH_IF ((opcode = 0x5c) && (pic_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - pic_penal
 * 							pic_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 						// movement
 * 						PATCH_IF ((opcode = 0x7e) && (mov_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4    par1 - mov_penal / 10
 * 							mov_penal_done = 1
 * 							done += 1
 * 							END
 * 
 * 					    //thieving disabling
 * 						PATCH_IF ((opcode = 0x90) && ((par2 = 0) || (par2 = 1))) THEN
 * 							BEGIN
 * 							DELETE_BYTES (eq_eff_indx + i) * 0x30 + eff_off 0x30
 * 							torem += 1
 * 							i -= 1
 * 							eq_eff_count -= 1
 * 							END
 * 
 * 				        //spellcasting disabling
 * 						PATCH_IF ((opcode = 0x91) && (par2 = 0)) THEN
 * 							BEGIN
 * 							DELETE_BYTES (eq_eff_indx + i) * 0x30 + eff_off 0x30
 * 							torem += 1
 * 							i -= 1
 * 							eq_eff_count -= 1
 * 							END
 * 
 * 				        //AC setting ... we will rebuild this
 * 						PATCH_IF (opcode = 0x0) THEN
 * 							BEGIN
 * 							DELETE_BYTES (eq_eff_indx + i) * 0x30 + eff_off 0x30
 * 							torem += 1
 * 							i -= 1
 * 							eq_eff_count -= 1
 * 							END
 * 
 * 						// hide in shadows
 * 						PATCH_IF ((opcode = 0x113) && (hid_penal_done = 0) && (par2 = 0)) THEN
 * 							BEGIN
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 par1 - hid_penal
 * 							hid_penal_done = 1
 * 							done += 1
 * 							END
 * 			END // searching all effects for duplicates of existing refined vaues
 * 
 * 
 * 			// now, add manually any other effect
 *             // IMPORTANT! KEEP THIS IN SYNC if you add extra effects-to-be-manipulated.
 * 	    	toadd = 14 - done
 * 
 * 				// what follows will update /all/ the extension header effect index if they come after this one.
 * 
 * 				FOR (ext_cyc_1 = 0; ext_cyc_1 < ext_count; ext_cyc_1 += 1) BEGIN
 * 
 * 					// read this ext header effect's index; if greater than the /old/ one of the just added section,
 * 					// increment by 1
 * 
 * 					READ_SHORT (ext_off + (ext_cyc_1 * 0x38) + 0x20) ext1_eff_idx
 * 
 * 					PATCH_IF (ext1_eff_idx > eq_eff_indx) BEGIN
 * 								WRITE_SHORT (ext_off + (ext_cyc_1 * 0x38) + 0x20) ext1_eff_idx + toadd - torem
 * 					END
 * 				END //FOR
 * 
 * 		INSERT_BYTES eff_off + 0x30 * eq_eff_indx 0x30 * toadd
 * 		WRITE_SHORT 0x70 eq_eff_count + toadd
 * 		switch = 0
 * 		FOR (i = 0; i < toadd; i += 1)
 * 			BEGIN
 * 
 * 				// standard values
 * 			    WRITE_BYTE  (eq_eff_indx + i) * 0x30 + eff_off + 2    1   // on self
 * 			    WRITE_BYTE  (eq_eff_indx + i) * 0x30 + eff_off + 3	  10  // power
 * 			    WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 8    0   // par2
 * 			    WRITE_BYTE  (eq_eff_indx + i) * 0x30 + eff_off + 0xc  2   // while equiped
 * 			    WRITE_BYTE  (eq_eff_indx + i) * 0x30 + eff_off + 0x12 100 // probability1
 * 
 * 					    // base ac
 * 						PATCH_IF (switch = 0) && (base_ac_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x0
 * 							WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 4    base_ac - magic_level / 2
 * 							WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 8    0x10
 * 							base_ac_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 					    // ac vs missiles (for the missile attractor)
 * 						PATCH_IF (switch = 0) && (missile_ac_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x0
 * 							WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 4    missile_ac
 * 							WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 8    0x02
 * 							missile_ac_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// slashing damage
 * 						PATCH_IF (switch = 0) && (dam_slash_done = 0) THEN
 * 						BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x56
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     dam_slash
 * 							dam_slash_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// crushing damage
 * 						PATCH_IF (switch = 0) && (dam_blunt_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x57
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     dam_blunt
 * 							dam_blunt_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// piercing damage
 * 						PATCH_IF (switch = 0) && (dam_pierc_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x58
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     dam_pierc
 * 							dam_pierc_done = 1
 * 							switch = 1
 * 							done += 1
 * 							END
 * 
 * 						// missile damage
 * 						PATCH_IF (switch = 0) && (dam_missi_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x59
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     dam_missi
 * 							dam_missi_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 					    // dexterity
 * 						PATCH_IF (switch = 0) && (dex_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0xf
 * 							WRITE_LONG  (eq_eff_indx + i) * 0x30 + eff_off + 4    0 - dex_penal
 * 							dex_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// movement
 * 						PATCH_IF (switch = 0) && (mov_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x7e
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     0 - mov_penal / 10
 * 							mov_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// spell failure
 * 						PATCH_IF (switch = 0) && (spe_failu_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x3c
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     spe_failu
 * 							spe_failu_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// move silently
 * 						PATCH_IF (switch = 0) && (sil_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x3b
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     0 - sil_penal
 * 							sil_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// open locks
 * 						PATCH_IF (switch = 0) && (loc_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x5a
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     0 - loc_penal
 * 							loc_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// find traps
 * 						PATCH_IF (switch = 0) && (tra_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x5b
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     0 - tra_penal
 * 							tra_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// pick pockets
 * 						PATCH_IF (switch = 0) && (pic_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x5c
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4     0 - pic_penal
 * 							pic_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 
 * 						// hide in shadows
 * 						PATCH_IF (switch = 0) && (hid_penal_done = 0) THEN
 * 							BEGIN
 * 							WRITE_SHORT (eq_eff_indx + i) * 0x30 + eff_off        0x113
 * 							WRITE_LONG (eq_eff_indx + i) * 0x30 + eff_off + 4 0 - hid_penal
 * 							hid_penal_done = 1
 * 							done += 1
 * 							switch = 1
 * 							END
 * 						switch = 0
 * 			END // adding all missing effecs
 * 		END // base_ac != 10: is armor
 * 	ELSE
 * 		BEGIN // reduce Dex requirements, so npcs still can use their equipment with heavy armour.
 * 			READ_BYTE  0x2c min_dex
 * 			WRITE_BYTE 0x2c (((min_dex - 4) < 0) ? 0 : (min_dex - 4))
 * 		END
 * BUT_ONLY_IF_IT_CHANGES
 * 
 * 
 * // now, we have to turn all cases of "movement modifier - set % of" to "movement modifier - add + x."
 * COPY_EXISTING_REGEXP GLOB ~.*\.spl~ ~override~
 * 						~.*\.itm~ ~override~
 * 	PATCH_IF SOURCE_SIZE > 0 BEGIN
 * 		READ_ASCII 0 whatis (3)
 * 		PATCH_IF (~%whatis%~ STRING_EQUAL_CASE ~ITM~) // if it's a ITM
 * 			BEGIN
 * 				extended_header_size = 0x38
 * 				END
 * 		ELSE
 * 			BEGIN // otherwise it's a SPL
 * 				extended_header_size = 0x28
 * 				END
 * 			READ_LONG 0x64 ext_off
 * 			READ_SHORT 0x68 ext_count
 * 		READ_LONG 0x6a eff_off
 * 		READ_SHORT 0x6e eq_eff_indx
 * 		READ_SHORT 0x70 eq_eff_count
 * 		// check all equiped / global EFFS
 * 		FOR (i = 0; i < eq_eff_count; i += 1)
 * 			BEGIN
 * 			READ_SHORT (0x30 * i + eq_eff_indx) + eff_off     opcode ELSE 0
 * 			READ_LONG  (0x30 * i + eq_eff_indx) + eff_off + 4 par1 ELSE 0
 * 			READ_LONG  (0x30 * i + eq_eff_indx) + eff_off + 8 par2 ELSE 0
 * 			PATCH_IF (opcode = 0x7e) && (par2 = 2)
 * 				BEGIN
 * 				WRITE_LONG (0x30 * i + eq_eff_indx) + eff_off + 8 0
 * 				WRITE_LONG (0x30 * i + eq_eff_indx) + eff_off + 4 (par1 - 100) / 10
 * 				END
 * 			END
 * 
 * 		// extended header EFFS
 * 		FOR (j = 0; j < ext_count; j += 1)
 * 			BEGIN
 * 				READ_SHORT (ext_off + (j * extended_header_size) + 0x1e) ext_eff_count ELSE 0
 * 				READ_SHORT (ext_off + (j * extended_header_size) + 0x20) ext_eff_indx ELSE 0
 * 
 * 				FOR (i = 0; i < ext_eff_count; i += 1)
 * 				BEGIN
 * 				READ_SHORT (0x30 * i + ext_eff_indx) + eff_off     opcode ELSE 0
 * 				READ_LONG  (0x30 * i + ext_eff_indx) + eff_off + 4 par1 ELSE 0
 * 				READ_LONG  (0x30 * i + ext_eff_indx) + eff_off + 8 par2 ELSE 0
 * 
 * 				PATCH_IF (opcode = 0x7e) && (par2 = 2)
 * 					BEGIN
 * 					WRITE_LONG (0x30 * i + ext_eff_indx) + eff_off + 8 0
 * 					WRITE_LONG (0x30 * i + ext_eff_indx) + eff_off + 4 (par1 - 100) / 10
 * 					END
 * 				END
 * 			END
 * 	END
 * BUT_ONLY_IF_IT_CHANGES
 * 
 * // EFF files
 * COPY_EXISTING_REGEXP GLOB ~.*\.eff~ ~override~
 * 		READ_LONG 0x10 opcode
 * 		READ_LONG 0x1c par1
 * 		READ_LONG 0x20 par2
 * 	PATCH_IF (opcode = 0x7e) && (par2 = 2)
 * 		BEGIN
 * 		WRITE_LONG 0x1c 0
 * 		WRITE_LONG 0x20 (par1 - 100) / 10
 * 		END
 * BUT_ONLY_IF_IT_CHANGES
 * 
 */
